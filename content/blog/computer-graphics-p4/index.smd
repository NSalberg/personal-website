---
.title = "Computer Graphics Project 4 - OpenGL",
.date = @date("2025-11-22:00:00"),
.author = "Nathan Salberg",
.layout = "post.shtml",
.draft = false,
--- 


In this assignment I was tasked with implementing a simple maze game using OpenGL and SDL. The player explores the environment looking for keys which will open doors until the goal is found. 

The map that the player explores is defined by a grid of characters. Walkable areas are represented by 0s, walls by Ws, keys by lowercase letters, and doors by uppercase letters.
```
5 5
0000G
WW0W0
0WAW0
0W0WW
S000a
```
Initially, I attempted to write the assignment using the example code from HW4, however I got sick of writing C++ real fast. I simply do not enjoy writing C++, so I ported the code to a language I enjoy - Zig.

To start I needed to find zig libraries to call OpenGL, SDL, and GLM. I could have directly imported the c headers but why do that when existing, more Zig friendly, bindings exist.

Luckily, the [SDL]($link.url('https://github.com/castholm/SDL')) project also provides a port of the project that uses the Zig build system. This made it super easy to import sdl functions I need.


Now for OpenGL, [zigglgen]($link.url('https://github.com/castholm/zigglgen')) provides a very nice wrapper around the OpenGL library.


zigglgen generates declarations for OpenGL functions, constants, types and extensions using the original names as
defined in the various OpenGL specifications (as opposed to the prefixed names used in C).

|           | C                     | Zig                |
|-----------|:----------------------|:-------------------|
| Command   | `glClearColor`        | `ClearColor`       |
| Constant  | `GL_TRIANGLES`        | `TRIANGLES`        |
| Type      | `GLfloat`             | `float`            |
| Extension | `GL_ARB_clip_control` | `ARB_clip_control` |


And for the math library, I used [zlm]($link.url('https://github.com/ziglibs/zlm')) which aims to be a Zig implementation of the GLM library.

To start, I reimplemented the scene parser. 

The scene parser populates an array list with the map of the maze. It also marks important positions like location of the player and of the goal.


```
pub var player_pos: Vec3 = undefined;
pub var goal_pos: Vec2 = undefined;
pub var map_width: usize = 0;
pub var map_height: usize = 0;
pub var game_map: std.ArrayList([]u8) = undefined;
pub var keys_collected: std.AutoHashMap(u8, void) = undefined;
```

After parsing the scene we need to initialize SDL.

```zig
try errify(c.SDL_Init(c.SDL_INIT_VIDEO));
try errify(c.SDL_GL_SetAttribute(c.SDL_GL_CONTEXT_MAJOR_VERSION, 3));
try errify(c.SDL_GL_SetAttribute(c.SDL_GL_CONTEXT_MINOR_VERSION, 2));
try errify(c.SDL_GL_SetAttribute(c.SDL_GL_CONTEXT_PROFILE_MASK, c.SDL_GL_CONTEXT_PROFILE_CORE));
window = try errify(c.SDL_CreateWindow(window_title, window_w, window_h, c.SDL_WINDOW_OPENGL));
gl_context = try errify(c.SDL_GL_CreateContext(window));
```

Then create the shaders 

```
const vertex_shader_source =
    \\in vec3 position;
    \\in vec3 inNormal;
    \\in vec2 inTexCoord;
    \\out vec3 fragPos;
    \\out vec3 normal;
    \\out vec2 texCoord;
    \\out vec3 vertColor;
    \\uniform mat4 model;
    \\uniform mat4 view;
    \\uniform mat4 proj;
    \\uniform vec3 objectColor;
    \\void main() {
    \\    fragPos = vec3(model * vec4(position, 1.0));
    \\    normal = mat3(transpose(inverse(model))) * inNormal;
    \\    texCoord = inTexCoord;
    \\    vertColor = objectColor;
    \\    gl_Position = proj * view * model * vec4(position, 1.0);
    \\ }
    \\
;
const fragment_shader_source =
    \\in vec3 fragPos;
    \\in vec3 normal;
    \\in vec2 texCoord;
    \\in vec3 vertColor;
    \\out vec4 outColor;
    \\uniform vec3 lightPos;
    \\uniform vec3 viewPos;
    \\uniform float ambient;
    \\uniform float useCheckerboard;
    \\void main() {
    \\    vec3 color = vertColor;
    \\    // Checkerboard pattern for floor
    \\    if (useCheckerboard > 0.5) {
    \\        float scale = 2.0;
    \\        int cx = int(floor(texCoord.x * scale));
    \\        int cy = int(floor(texCoord.y * scale));
    \\        if ((cx + cy) % 2 == 0) color *= 0.7;
    \\    }
    \\    // Ambient
    \\    vec3 ambientLight = ambient * color;
    \\    // Diffuse
    \\    vec3 norm = normalize(normal);
    \\    vec3 lightDir = normalize(lightPos - fragPos);
    \\    float diff = max(dot(norm, lightDir), 0.0);
    \\    vec3 diffuse = diff * color;
    \\    // Specular
    \\    vec3 viewDir = normalize(viewPos - fragPos);
    \\    vec3 reflectDir = reflect(-lightDir, norm);
    \\    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
    \\    vec3 specular = 0.3 * spec * vec3(1.0);
    \\    outColor = vec4(ambientLight + diffuse + specular, 1.0);
    \\}
;


if (!gl_procs.init(&c.SDL_GL_GetProcAddress)) return error.GlInitFailed;

gl.makeProcTableCurrent(&gl_procs);
errdefer gl.makeProcTableCurrent(null);



[reflection.png]($image.asset("reflection.png").size(0,300))


**Code**


[zipfile]($link.asset('project3-nathan-salberg.zip'))

The code requires zig version 0.15.1 or greater and can be compiled with
`zig build -Doptimize=ReleaseFast`

Then the executable can be run with `./zig-out/bin/project_3a MyScenes/camera_pos.txt`

**Additional Scenes**

[spheres2.png]($image.asset("spheres2.png").size(0,300))




